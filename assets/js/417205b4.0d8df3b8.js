"use strict";(self.webpackChunkls_fusion_docs=self.webpackChunkls_fusion_docs||[]).push([[72550],{37827:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>d,default:()=>l,frontMatter:()=>o,metadata:()=>i,toc:()=>a});var n=t(74848),s=t(28453);const o={title:"Change operators (SET, CHANGED, ...)"},d=void 0,i={id:"Change_operators_SET_CHANGED_etc",title:"Change operators (SET, CHANGED, ...)",description:"Change operators determine whether some types of changes have occurred for a certain property in the current session. All these operators are derived from the previous value operator (PREV), however, it is recommended to use them to improve readability and performance. The following table shows the supported types of changes and their description:",source:"@site/docs/Change_operators_SET_CHANGED_etc.md",sourceDirName:".",slug:"/Change_operators_SET_CHANGED_etc",permalink:"/next/Change_operators_SET_CHANGED_etc",draft:!1,unlisted:!1,editUrl:"https://github.com/lsfusion/platform/edit/master/docs/en/Change_operators_SET_CHANGED_etc.md",tags:[],version:"current",lastUpdatedAt:1623249583,formattedLastUpdatedAt:"Jun 9, 2021",frontMatter:{title:"Change operators (SET, CHANGED, ...)"},sidebar:"learn",previous:{title:"Previous value (PREV)",permalink:"/next/Previous_value_PREV"},next:{title:"User/IS interaction",permalink:"/next/User_IS_interaction"}},c={},a=[{value:"Language",id:"language",level:3},{value:"Examples",id:"examples",level:3}];function h(e){const r={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.em,{children:"Change operators"})," determine whether some types of changes have occurred for a certain property in the current session. All these operators are derived from the ",(0,n.jsxs)(r.a,{href:"/next/Previous_value_PREV",children:["previous value operator (",(0,n.jsx)(r.code,{children:"PREV"}),")"]}),", however, it is recommended to use them to improve readability and performance. The following table shows the supported types of changes and their description:"]}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.th,{children:"Operator"}),(0,n.jsx)(r.th,{children:"Value"}),(0,n.jsx)(r.th,{children:"Description"})]})}),(0,n.jsxs)(r.tbody,{children:[(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"SET"})}),(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"f AND NOT PREV(f)"})}),(0,n.jsx)(r.td,{children:"Value is set"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"DROPPED"})}),(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"NOT f AND PREV(f)"})}),(0,n.jsx)(r.td,{children:"Value is reset"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"CHANGED"})}),(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"(f OR PREV(f)) AND NOT f==PREV(f)"})}),(0,n.jsx)(r.td,{children:"Value is changed"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"SETCHANGED"})}),(0,n.jsxs)(r.td,{children:[(0,n.jsx)(r.code,{children:"f AND NOT f==PREV(f)"}),(0,n.jsx)("br",{}),"or",(0,n.jsx)("br",{}),(0,n.jsx)(r.code,{children:"CHANGED(f) AND NOT DROPPED(f)"})]}),(0,n.jsxs)(r.td,{children:["Value is changed to non-",(0,n.jsx)(r.code,{children:"NULL"})]})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"DROPCHANGED"})}),(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"CHANGED(f) AND NOT SET(f)"})}),(0,n.jsxs)(r.td,{children:["Value is either reset or changed from one non-",(0,n.jsx)(r.code,{children:"NULL"})," to another non-",(0,n.jsx)(r.code,{children:"NULL"})]})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"SETDROPPED"})}),(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"SET(f) OR DROPPED(f)"})}),(0,n.jsxs)(r.td,{children:["Value is either reset or changed from ",(0,n.jsx)(r.code,{children:"NULL"})," to non-",(0,n.jsx)(r.code,{children:"NULL"})]})]})]})]}),"\n",(0,n.jsx)(r.admonition,{type:"caution",children:(0,n.jsxs)(r.p,{children:["These operators are computed differently inside the ",(0,n.jsx)(r.a,{href:"/next/Events#change",children:"event"})," handler: in this case, they return changes from the point of the previous occurrence of this event, or rather, from the point at which all its handlers are completed."]})}),"\n",(0,n.jsx)(r.h3,{id:"language",children:"Language"}),"\n",(0,n.jsxs)(r.p,{children:["To declare a property using change operators, the following ",(0,n.jsx)(r.a,{href:"/next/Change_operators",children:"syntax constructs"})," are used."]}),"\n",(0,n.jsx)(r.h3,{id:"examples",children:"Examples"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-lsf",children:"quantity = DATA NUMERIC[14,2] (OrderDetail);\nprice = DATA NUMERIC[14,2] (OrderDetail);\nsum(OrderDetail d) <- quantity(d) * price(d) WHEN CHANGED(quantity(d)) OR CHANGED(price(d));\n\ncreatedUser = DATA CustomUser (Order);\ncreatedUser (Order o) <- currentUser() WHEN SET(o IS Order);\n\nnumerator = DATA Numerator (Order);\nnumber = DATA STRING[28] (Order);\nseries = DATA BPSTRING[2] (Order);\nWHEN SETCHANGED(numerator(Order o)) AND\n     NOT CHANGED(number(o)) AND\n     NOT CHANGED(series(o))\n     DO {\n        number(o) <- curStringValue(numerator(o));\n        series(o) <- series(numerator(o));\n        incrementValueSession(numerator(o));\n     }\n;\n"})})]})}function l(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},28453:(e,r,t)=>{t.d(r,{R:()=>d,x:()=>i});var n=t(96540);const s={},o=n.createContext(s);function d(e){const r=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),n.createElement(o.Provider,{value:r},e.children)}}}]);
"use strict";(self.webpackChunkls_fusion_docs=self.webpackChunkls_fusion_docs||[]).push([[60214],{92350:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>a});var i=t(74848),s=t(28453);const r={title:"ABSTRACT operator"},c=void 0,o={id:"ABSTRACT_action_operator",title:"ABSTRACT operator",description:"The ABSTRACT operator - creating an abstract action.",source:"@site/docs/ABSTRACT_action_operator.md",sourceDirName:".",slug:"/ABSTRACT_action_operator",permalink:"/next/ABSTRACT_action_operator",draft:!1,unlisted:!1,editUrl:"https://github.com/lsfusion/platform/edit/master/docs/en/ABSTRACT_action_operator.md",tags:[],version:"current",lastUpdatedAt:1708525070,formattedLastUpdatedAt:"Feb 21, 2024",frontMatter:{title:"ABSTRACT operator"},sidebar:"learn",previous:{title:"{...} operator",permalink:"/next/Braces_operator"},next:{title:"ACTIVATE operator",permalink:"/next/ACTIVATE_operator"}},l={},a=[{value:"Syntax",id:"syntax",level:3},{value:"Description",id:"description",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Examples",id:"examples",level:3}];function d(e){const n={a:"a",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ABSTRACT"})," operator - creating an ",(0,i.jsx)(n.a,{href:"/next/Action_extension",children:"abstract action"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"syntax",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ABSTRACT [type [exclusionType]] [FIRST | LAST] [CHECKED] (argClassName1, ..., argClassNameN) \n"})}),"\n",(0,i.jsx)(n.h3,{id:"description",children:"Description"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ABSTRACT"})," operator creates an abstract action, the implementation of which can be defined later (for example, in other ",(0,i.jsx)(n.a,{href:"/next/Modules",children:"modules"})," dependent on the module containing the ",(0,i.jsx)(n.code,{children:"ABSTRACT"})," action). Implementations are added to the action using the ",(0,i.jsxs)(n.a,{href:"/next/ACTION+_statement",children:[(0,i.jsx)(n.code,{children:"ACTION+"})," statement"]}),". When executing ",(0,i.jsx)(n.code,{children:"MULTI"})," or ",(0,i.jsx)(n.code,{children:"CASE"})," type abstract actions, their matching implementation is selected and executed. The selection of the matching implementation depends on the selection conditions that are defined when adding implementations, and on the ",(0,i.jsx)(n.code,{children:"ABSTRACT"})," operator type."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CASE"})," - a general case. The selection condition will be explicitly specified in the implementation using the ",(0,i.jsxs)(n.a,{href:"/next/ACTION+_statement",children:[(0,i.jsx)(n.code,{children:"WHEN"})," block"]}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"MULTI"})," - ",(0,i.jsx)(n.a,{href:"/next/Branching_CASE_IF_MULTI#poly",children:"a polymorphic form"}),". The selection condition is that the parameters match the implementation ",(0,i.jsx)(n.a,{href:"/next/CLASS_operator",children:"signature"}),". This type is the default type and need not be explicitly specified."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"/next/Branching_CASE_IF_MULTI#exclusive",children:"type of mutual exclusion"})," of an operator determines whether several conditions for the implementation of an abstract action can simultaneously be met with a certain set of parameters. The ",(0,i.jsx)(n.code,{children:"EXCLUSIVE"})," type indicates that implementation conditions cannot be met simultaneously. The ",(0,i.jsx)(n.code,{children:"OVERRIDE"})," type allows several simultaneously fulfilled conditions, while which implementation is ultimately selected is determined by the keywords ",(0,i.jsx)(n.code,{children:"FIRST"})," and ",(0,i.jsx)(n.code,{children:"LAST"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["When performing a ",(0,i.jsx)(n.code,{children:"LIST"})," abstract action, all implementations are executed sequentially. The implementation order is determined by the keywords ",(0,i.jsx)(n.code,{children:"FIRST"})," and ",(0,i.jsx)(n.code,{children:"LAST"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ABSTRACT"})," operator cannot be used inside the ",(0,i.jsxs)(n.a,{href:"/next/Braces_operator",children:[(0,i.jsx)(n.code,{children:"{...}"})," operator"]}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"type"})}),"\n",(0,i.jsx)(n.p,{children:"Type of abstract action. It is specified by one of these keywords:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"CASE"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"MULTI"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"LIST"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The default value is ",(0,i.jsx)(n.code,{children:"MULTI"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"exclusionType"})}),"\n",(0,i.jsxs)(n.p,{children:["Type of mutual exclusion. One of these keywords: ",(0,i.jsx)(n.code,{children:"EXCLUSIVE"})," or ",(0,i.jsx)(n.code,{children:"OVERRIDE"}),". Unless explicitly specified, in a ",(0,i.jsx)(n.code,{children:"MULTI"})," abstract action the default type of mutual exclusion is ",(0,i.jsx)(n.code,{children:"EXCLUSIVE"}),", and in a ",(0,i.jsx)(n.code,{children:"CASE"})," action the default type is ",(0,i.jsx)(n.code,{children:"OVERRIDE"}),". For a ",(0,i.jsx)(n.code,{children:"LIST"})," abstract action the type of mutual exclusion is not specified."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"FIRST"})," | ",(0,i.jsx)(n.code,{children:"LAST"})]}),"\n",(0,i.jsxs)(n.p,{children:["Keywords. When the word ",(0,i.jsx)(n.code,{children:"FIRST"})," is specified, implementations will be added to the top of the implementations list; when ",(0,i.jsx)(n.code,{children:"LAST"})," is specified, implementations will be added to the end of the implementations list. Unless specified, the default is ",(0,i.jsx)(n.code,{children:"FIRST"})," (except ",(0,i.jsx)(n.code,{children:"LIST"}),", where the default is ",(0,i.jsx)(n.code,{children:"LAST"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["For abstract actions such as ",(0,i.jsx)(n.code,{children:"CASE"})," and ",(0,i.jsx)(n.code,{children:"MULTI"})," with the type of mutual exclusion ",(0,i.jsx)(n.code,{children:"OVERRIDE"}),", specifying ",(0,i.jsx)(n.code,{children:"FIRST"})," will mean that of the matching implementations, the last one added will be executed. For actions such as ",(0,i.jsx)(n.code,{children:"LIST"}),", specifying ",(0,i.jsx)(n.code,{children:"FIRST"})," will mean that implementations will be executed in the reverse order of their addition."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"CHECKED"})}),"\n",(0,i.jsx)(n.p,{children:"Keyword. If specified, the platform will automatically check that at least one implementation is defined for all descendants of the argument classes (or exactly one, if the conditions are mutually exclusive)."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"argClassName1, ..., argClassNameN"})}),"\n",(0,i.jsxs)(n.p,{children:["List of class names of property arguments. Each name is defined by a ",(0,i.jsx)(n.a,{href:"/next/IDs#classid",children:"class ID"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lsf",children:"exportXls 'Export to Excel' ABSTRACT CASE (Order); // ABSTRACT CASE OVERRIDE LAST is created         \r\nexportXls (Order o) + WHEN name(currency(o)) == 'USD' THEN {\r\n    MESSAGE 'Export USD not implemented';\r\n}\r\n\r\nCLASS Task;\r\nrun 'Execute' ABSTRACT (Task); // ABSTRACT MULTI EXCLUSIVE\r\n\r\nCLASS Task1 : Task;\r\nname = DATA STRING[100] (Task);\r\nrun (Task1 t) + {\r\n    MESSAGE 'Run Task1 ' + name(t);\r\n}\r\n\r\n\r\nCLASS OrderDetail;\r\nprice = DATA NUMERIC[14,2] (OrderDetail);\r\n\r\nCLASS InvoiceDetail;\r\nprice = DATA NUMERIC[14,2] (InvoiceDetail);\r\nfill ABSTRACT LIST (OrderDetail, InvoiceDetail); // ABSTRACT LIST LAST\r\n\r\nfill (OrderDetail od, InvoiceDetail id) + {\r\n    price(id) <- price(od);\r\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>o});var i=t(96540);const s={},r=i.createContext(s);function c(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);